<!DOCTYPE html>
<html lang="en-US">
<head>
    <title>WebGL Class Test</title>

    <script src="glMatrix-0.9.5.min.js"></script>

    <style>
        #canvasContainer {
            width: 640px;
            height: 480px;
            overflow: hidden;
            margin-left: auto;
            margin-right: auto;
        }
        #myCanvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

    <div id="canvasContainer">
        <canvas id="myCanvas"></canvas>
    </div>

    <!-- fragment and vertex shader used -->
    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;
    
        void main(void) {
            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
    </script>
    
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
    
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
    
        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        }
    </script>

    <script>

        // Used in Shader constructor to get the vertex and fragment shader text
        var getElementText = function(el) {
            var str = "";
            var k = el.firstChild;
            while(k) {
                if(k.nodeType == 3) {
                    str += k.textContent;
                }
                k = k.nextSibling;
            }

            return str;
        }

        // the global move matrix
        var mvMatrix = mat4.create();

        class Shader {
            // vertId and fragId are the html elements containing the vertex and fragment shader code
            constructor(gl, vertId, fragId) {
                this._vertShader = gl.createShader(gl.VERTEX_SHADER);
                this._fragShader = gl.createShader(gl.FRAGMENT_SHADER);

                this._shaderProg = gl.createProgram();

                // get and send the text of the respective elements
                var vertShaderElement = document.getElementById(vertId);
                if(!vertShaderElement) {
                    alert('Failed to find vertex shader element with id: ', vertId);
                    return;
                }
                var fragShaderElement = document.getElementById(fragId);
                if(!fragShaderElement) {
                    alert('Failed to find fragment shader element with id: ', fragId);
                    return;
                }

                var vertStr = getElementText(vertShaderElement);
                var fragStr = getElementText(fragShaderElement);

                // compile the text of each element
                gl.shaderSource(this._vertShader, vertStr);
                gl.compileShader(this._vertShader);

                gl.shaderSource(this._fragShader, fragStr);
                gl.compileShader(this._fragShader);

                // verify its all good
                if(!gl.getShaderParameter(this._vertShader, gl.COMPILE_STATUS)) {
                    alert(gl.getShaderInfoLog(this._vertShader));
                    return;
                }
                if(!gl.getShaderParameter(this._fragShader, gl.COMPILE_STATUS)) {
                    alert(gl.getShaderInfoLog(this._fragShader));
                    return;
                }

                // attach the vertex and fragment shaders to the total program
                gl.attachShader(this._shaderProg, this._vertShader);
                gl.attachShader(this._shaderProg, this._fragShader);
                gl.linkProgram(this._shaderProg);

                // verify its all good again
                if(!gl.getProgramParameter(this._shaderProg, gl.LINK_STATUS)) {
                    alert('Failed to link shader program!');
                }

                this.use(gl);

                this._shaderProg.vertexPositionAttribute = gl.getAttribLocation(this._shaderProg, "aVertexPosition");
                gl.enableVertexAttribArray(this._shaderProg.vertexPositionAttribute);

                this._shaderProg.pMatrixUniform = gl.getUniformLocation(this._shaderProg, "uPMatrix");
                this._shaderProg.mvMatrixUniform = gl.getUniformLocation(this._shaderProg, "uMVMatrix");
            }

            use(gl) {
                gl.useProgram(this._shaderProg);
            }
        }

        class Display {
            
            // constructor
            constructor(canvasIdStr) {
                // get the canvas
                this._canvas = document.getElementById(canvasIdStr);
                if(!this._canvas){
                    alert('Display constructor: failed to load canvas!');
                }

                // get the WebGL context
                this._gl = this._canvas.getContext("experimental-webgl");
                if(!this._gl){
                    alert('Display constructor: failed to initialize WebGL!');
                }
                this._gl.viewportWidth  = this.canvas.width;
                this._gl.viewportHeight = this.canvas.height;

                // enable the z buffer
                this._gl.enable(this._gl.DEPTH_TEST);
            }

            // clears the buffer bits and sets the viewport width
            clear() {
                this._gl.viewport(0, 0, this._gl.viewportWidth, this._gl.viewportHeight);
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
            }

            // getter functions
            get canvas() {
                return this._canvas;
            }
            get glContext() {
                return this._gl;
            }
        }

        class Camera {
            constructor(pos) {
                // vec3 representing the camera's position
                this._pos = pos;

                // initialize the projection matrix
                this._projMat = mat4.create();
            }

            // set the camera's projection matrix
            perspective(gl) {
                mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, this._projMat);
            }
        }

        class Object {
            constructor(pos) {
                // vec3 representing the object's position
                this._pos = pos;

                // position buffer
                this._VBO = 0;
            }

            // draw the object
            // mvMatrix is global and pMatrix is stored in camera
            draw(gl, shaderID, pMatrix, mvMatrix) {
                // move to where we're drawing
                mat4.translate(mvMatrix, this._pos);

                // bind draw the object
                gl.bindBuffer(gl.ARRAY_BUFFER, this._VBO);
                gl.vertexAttribPointer(
                    shaderID.vertexPositionAttribute,
                    this._VBO.itemSize,
                    gl.FLOAT,
                    false,
                    0, 0
                );

                gl.uniformMatrix4fv(shaderID.pMatrixUniform, false, pMatrix);
                gl.uniformMatrix4fv(shaderID.mvMatrixUniform, false, mvMatrix);

                gl.drawArrays(gl.TRIANGLES, 0, this._VBO.numItems);
            }
            
        }

        var display = new Display("myCanvas");
        var camera = new Camera([0.0, 0.0, 0.0]); // pos at 0.0
        var shader = new Shader(display.glContext, "shader-vs", "shader-fs");
        
        // set the bg color and clear the canvas
        display.glContext.clearColor(0.0, 0.3, 0.3, 1.0);
        display.clear();

        // set the opengl projection matrix
        camera.perspective(display.glContext);


    </script>

</body>
</html>